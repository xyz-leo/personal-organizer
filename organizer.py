"""
An Personal Organizer App using PySide6.

This application allows users to manage tasks or notes within multiple workspaces.
Data is persisted locally using SQLite.

Key features:
- Add, edit, and delete tasks
- Create and switch between workspaces
- Lightweight UI with custom styling
- Persistent storage in ./files/tasks.db

Author: xyz-leo
"""

import sys, sqlite3
import os
from PySide6.QtGui import QFont, QColor, QPalette, QAction, QIcon
from PySide6.QtCore import Qt, Signal, QEvent
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QHBoxLayout, QVBoxLayout,
    QListWidget, QListWidgetItem, QTextEdit, QLineEdit, QPushButton, QLabel,
    QMenu, QInputDialog, QComboBox, QMessageBox
)


# Paths -- .file folder, sqlite and app icon
DB_FOLDER = ".files"
os.makedirs(DB_FOLDER, exist_ok=True)
DB_PATH = os.path.join(DB_FOLDER, "tasks.db")
WINDOW_ICON = os.path.join(DB_FOLDER, "icon.png")


class TaskItem(QWidget):
    menuRequested = Signal(object) # Will be emited when the user clicks on the ... menu button

    def __init__(self, task_id, title, description=""):
        super().__init__()
        # Task properties
        self.task_id = task_id # Unique task identifier generated by the DB
        self._title = title # Task title
        self._description = description # Task description

        layout = QHBoxLayout(self) # Horizontal layout
        layout.setContentsMargins(5, 5, 5, 5)
    
        # Show the task title
        self.label = QLabel(title)
        self.label.setFont(QFont("Segoe UI", 14))
        layout.addWidget(self.label)
        layout.addStretch() # Ensure that the nearby widgets (menu button) is on the right side

        self.btn_menu = QPushButton("⋮")
        self.btn_menu.setFont(QFont("Segoe UI", 16))
        self.btn_menu.setFixedSize(30, 30)
        # Making a connection with the menuRequested signal
        self.btn_menu.clicked.connect(lambda: self.menuRequested.emit(self))
        layout.addWidget(self.btn_menu)


    # Allow access and update the task title. When the title is modified, QLabel is also updated.
    def getTitle(self): return self._title
    def setTitle(self, title): self._title = title; self.label.setText(title)
    # Allow access and update of the task description
    def getDescription(self): return self._description
    def setDescription(self, description): self._description = description


# Manages the main window of the app interface, events and tasks persistence
class App(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowIcon(QIcon(WINDOW_ICON))
        self.setWindowTitle("Personal Organizer") # Window title
        self.resize(900, 600) # Window size
        self.set_dark_theme() # Apply the dark theme
        # Connecting with the database
        self.conn = sqlite3.connect(DB_PATH)
        self.create_table() # Method to create a table tasks if it not exists.

        # Assembling the interface
        central_widget = QWidget() # Container for all componentes
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget) # Horizontal layout that divides the window in two areas, left and right panel.

        # Left Panel
        self.left_panel = QVBoxLayout()
        self.left_panel.setSpacing(10)
        self.left_panel.setContentsMargins(10, 10, 10, 10)


        # Button to go back to the create task section; located below the Menu label
        self.btn_create_mode = QPushButton("Create task")
        self.btn_create_mode.setFont(QFont("Segoe UI", 13))
        # Calling the create view method to show the "create view"
        self.btn_create_mode.clicked.connect(self.show_create_view)
        self.left_panel.addWidget(self.btn_create_mode)
       

        # Widget that shows the task list, every item in this list will use a TaskItem object
        self.task_list = QListWidget()
        self.task_list.setFont(QFont("Segoe UI", 15))

        self.left_panel.addWidget(self.task_list) 
        
        # the number 4 will define that the left panel will occupy 40% of width
        main_layout.addLayout(self.left_panel, 4)
        

        # Display a minimalist GitHub label of my username
        footer_layout = QHBoxLayout()

        footer = QLabel("github.com/xyz-leo")
        footer.setStyleSheet("color: gray; font-size: 10px; padding: 5px;")
        footer_layout.addWidget(footer)

        self.left_panel.addLayout(footer_layout)


        # Right panel
        self.right_panel = QVBoxLayout()
        self.right_panel.setContentsMargins(15, 15, 15, 15)
        main_layout.addLayout(self.right_panel, 7) # Define that the right panel will occupy 70% of width
        self.create_task_widget = self.build_create_task_widget() # Screen to create new tasks
        self.display_task_widget = self.build_display_task_widget() # Screen to show and edit a created task
 
        self.right_panel.addWidget(self.create_task_widget)
        self.right_panel.addWidget(self.display_task_widget)
        self.display_task_widget.hide() # The exibition screen is hided by default

        self.btn_send.clicked.connect(self.add_task) # Button in the creation screen, when is clicked, call the add task method
        self.task_list.itemClicked.connect(self.display_task) # When clicking an item in the list, call the display task method

        self.load_tasks() # Load the tasks in the DB and add to the list
        


    # Override   
    def eventFilter(self, source, event):
        # If event happened in the edit field of the task description
        if source == self.task_description_edit and event.type() == QEvent.KeyPress:
            # If the key pressed was Ctrl + S
            if event.key() == Qt.Key_S and event.modifiers() & Qt.ControlModifier:
                self.save_task_description()  # Call the method to save task
                return True
        return super().eventFilter(source, event)

    # Create the interace for the task creation
    def build_create_task_widget(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setAlignment(Qt.AlignCenter)

        label = QLabel("What task to be created?")
        label.setFont(QFont("Segoe UI", 20, QFont.Bold))
        label.setAlignment(Qt.AlignCenter)
        layout.addWidget(label)

        self.task_input = QLineEdit()
        self.task_input.setPlaceholderText("Task Title")
        self.task_input.setFont(QFont("Segoe UI", 15))
        self.task_input.setFixedWidth(300)
        self.task_input.setFixedHeight(40)

        self.task_input.returnPressed.connect(self.add_task) #

        self.current_workspace_id = None

        self.workspace_selector = QComboBox()
        self.workspace_selector.setFont(QFont("Segoe UI", 13))
        self.workspace_selector.currentIndexChanged.connect(self.change_workspace)

        self.btn_add_workspace = QPushButton("+")
        self.btn_add_workspace.setFixedSize(30, 30)
        self.btn_add_workspace.clicked.connect(self.create_workspace)

        workspace_layout = QHBoxLayout()
        label = QLabel("Workspace:")
        font = label.font()
        font.setPointSize(14) 
        label.setFont(font)
        workspace_layout.addWidget(label)
        workspace_layout.addWidget(self.workspace_selector)
        workspace_layout.addWidget(self.btn_add_workspace)
        
        self.remove_workspace_button = QPushButton("-")
        self.remove_workspace_button.setFixedWidth(30)
        self.remove_workspace_button.clicked.connect(self.remove_workspace)
        workspace_layout.addWidget(self.remove_workspace_button)

        self.left_panel.insertLayout(1, workspace_layout)

        self.load_workspaces()


        layout.addWidget(self.task_input, alignment=Qt.AlignCenter)

        self.btn_send = QPushButton("➜")
        self.btn_send.setFont(QFont("Segoe UI", 16))
        self.btn_send.setFixedSize(40, 40)
        layout.addWidget(self.btn_send, alignment=Qt.AlignCenter)

        return widget

    # Create the interface to show and edit a created task
    def build_display_task_widget(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setAlignment(Qt.AlignTop)

        self.task_title_display = QLabel("Task Title")
        self.task_title_display.setFont(QFont("Segoe UI", 18, QFont.Bold))
        layout.addWidget(self.task_title_display)

        self.task_description_edit = QTextEdit()
        self.task_description_edit.setFont(QFont("Segoe UI", 14))
        self.task_description_edit.installEventFilter(self)
        layout.addWidget(self.task_description_edit)

        self.save_button = QPushButton("Save")
        self.save_button.setFont(QFont("Segoe UI", 12))
        self.save_button.clicked.connect(self.save_task_description)
        layout.addWidget(self.save_button, alignment=Qt.AlignRight)

        return widget

    # Themes and style
    def set_dark_theme(self):
        palette = QPalette()
        palette.setColor(QPalette.Window, QColor(30, 30, 30))
        palette.setColor(QPalette.WindowText, Qt.white)
        palette.setColor(QPalette.Base, QColor(50, 50, 50))
        palette.setColor(QPalette.AlternateBase, QColor(45, 45, 45))
        palette.setColor(QPalette.Text, Qt.white)
        palette.setColor(QPalette.Button, QColor(45, 45, 45))
        palette.setColor(QPalette.ButtonText, Qt.white)
        palette.setColor(QPalette.Highlight, QColor(100, 100, 200))
        palette.setColor(QPalette.HighlightedText, Qt.black)
        self.setPalette(palette)

    # Task persistance with SQLite
    def create_table(self):
        self.conn.execute("""
        CREATE TABLE IF NOT EXISTS workspaces (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE
        )
        """)
        self.conn.execute("""
        CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            description TEXT,
            workspace_id INTEGER,
            FOREIGN KEY(workspace_id) REFERENCES workspaces(id)
        )
        """)
        self.conn.commit()


    # Adding tasks
    def add_task(self):
        title = self.task_input.text().strip()
        if title and self.current_workspace_id is not None:
            cur = self.conn.cursor()
            cur.execute("INSERT INTO tasks (title, description, workspace_id) VALUES (?, ?, ?)",
                        (title, "", self.current_workspace_id))
            task_id = cur.lastrowid
            self.conn.commit()
            self.add_task_to_list(task_id, title, "")
            self.task_input.clear()


    def add_task_to_list(self, task_id, title, description):
        task_widget = TaskItem(task_id, title, description)
        task_widget.menuRequested.connect(self.show_menu)
        item = QListWidgetItem()
        item.setSizeHint(task_widget.sizeHint())
        item.setData(Qt.UserRole, task_widget)
        self.task_list.addItem(item)
        self.task_list.setItemWidget(item, task_widget)


    # Displaying a task
    def display_task(self, item):
        task_widget = item.data(Qt.UserRole)
        if task_widget:
            self.selected_task = task_widget
            self.task_title_display.setText(task_widget.getTitle())
            self.task_description_edit.setText(task_widget.getDescription())
            self.show_display_view() # Change the view to the task


    # Alternating between views
    def show_create_view(self):
        self.display_task_widget.hide()
        self.create_task_widget.show()


    def show_display_view(self):
        self.create_task_widget.hide()
        self.display_task_widget.show()


    # Saving the changes in the task description
    def save_task_description(self):
        if hasattr(self, 'selected_task'):
            new_description = self.task_description_edit.toPlainText()
            self.selected_task.setDescription(new_description)
            self.conn.execute("UPDATE tasks SET description=? WHERE id=?",
                              (new_description, self.selected_task.task_id))
            self.conn.commit()

    # Renaming tasks
    def rename_task(self, task_widget):
        current_title = task_widget.getTitle()
        new_title, ok = QInputDialog.getText(self, "Rename Task", "New Title:", text=current_title)
        if ok and new_title.strip():
            task_widget.setTitle(new_title.strip())
            self.conn.execute("UPDATE tasks SET title=? WHERE id=?", (new_title.strip(), task_widget.task_id))
            self.conn.commit()
            if hasattr(self, 'selected_task') and self.selected_task == task_widget:
                self.task_title_display.setText(new_title.strip())

    # Removing tasks
    def remove_task(self, item):
        task_widget = item.data(Qt.UserRole)
        if task_widget:
            self.conn.execute("DELETE FROM tasks WHERE id=?", (task_widget.task_id,))
            self.conn.commit()
        row = self.task_list.row(item)
        self.task_list.takeItem(row)
        self.task_description_edit.clear()
        self.task_title_display.setText("")


    # Show the options menu
    def show_menu(self, task_widget):
        item = self.find_item_by_widget(task_widget)
        if not item: return

        menu = QMenu(self)
        rename_action = QAction("Rename", self)
        remove_action = QAction("Delete", self)

        rename_action.triggered.connect(lambda: self.rename_task(task_widget))
        remove_action.triggered.connect(lambda: self.remove_task(item))

        menu.addAction(rename_action)
        menu.addAction(remove_action)
        menu.exec(task_widget.btn_menu.mapToGlobal(task_widget.btn_menu.rect().bottomLeft()))
    

    # Locating an item by the Widget
    def find_item_by_widget(self, widget):
        for i in range(self.task_list.count()):
            item = self.task_list.item(i)
            if self.task_list.itemWidget(item) == widget:
                return item
        return None

    
    def load_tasks(self):
        if self.current_workspace_id is None:
            return
        self.task_list.clear()
        cursor = self.conn.execute(
            "SELECT id, title, description FROM tasks WHERE workspace_id = ?",
            (self.current_workspace_id,))
        for task_id, title, description in cursor.fetchall():
            self.add_task_to_list(task_id, title, description)

    def create_workspace(self):
        name, ok = QInputDialog.getText(self, "Create Workspace", "Workspace name:")
        if ok and name.strip():
            name = name.strip()
            try:
                self.conn.execute("INSERT INTO workspaces (name) VALUES (?)", (name,))
                self.conn.commit()
                self.load_workspaces()
                # Selecionar automaticamente o novo workspace
                index = self.workspace_selector.findText(name)
                if index != -1:
                    self.workspace_selector.setCurrentIndex(index)
            except sqlite3.IntegrityError:
                pass  # Nome duplicado


    def load_workspaces(self):
        self.workspace_selector.blockSignals(True)
        self.workspace_selector.clear()
        cursor = self.conn.execute("SELECT id, name FROM workspaces")
        workspaces = cursor.fetchall()

        if not workspaces:
            self.conn.execute("INSERT INTO workspaces (name) VALUES ('Home')")
            self.conn.commit()
            return self.load_workspaces()

        for wid, name in workspaces:
            self.workspace_selector.addItem(name, wid)

            self.workspace_selector.blockSignals(False)
            self.workspace_selector.setCurrentIndex(0)
            self.change_workspace(0)


    def change_workspace(self, index):
        # Get the workspace ID associated with the selected index
        self.current_workspace_id = self.workspace_selector.itemData(index)
        # Load tasks that belong to the selected workspace
        self.load_tasks()


    def remove_workspace(self):
        # Fetch a list of all workspace names from the database
        workspaces = [row[0] for row in self.conn.execute("SELECT name FROM workspaces").fetchall()]
        # If there are no workspaces, exit the function early
        if not workspaces:
            return
        # Show a dialog to select one of the existing workspaces to remove
        name, ok = QInputDialog.getItem(self, "Remove Workspace", "Select a workspace to remove:", workspaces, editable=False)
        
        # Proceed only if the user pressed OK and selected a name
        if ok and name:
            # Show a confirmation dialog before deleting the workspace
            reply = QMessageBox.question(self, "Confirm", f"Are you sure you want to delete '{name}'?",
                                         QMessageBox.Yes | QMessageBox.No)
            # If the user confirms, delete the selected workspace
            if reply == QMessageBox.Yes:
                # Delete the workspace from the workspaces table
                self.conn.execute("DELETE FROM workspaces WHERE name = ?", (name,))
                # Delete tasks that are no longer associated with any workspace
                self.conn.execute("DELETE FROM tasks WHERE workspace_id NOT IN (SELECT id FROM workspaces)")
                
                # Commit the changes to the database
                self.conn.commit()
                
                # Reload the workspace dropdown to reflect the change
                self.load_workspaces()


   
# Main
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = App()
    window.show()
    sys.exit(app.exec())
